Задача 4. Стековая машина
-------------------------

Рассмотрим язык, расширяющий язык из задачи обратная польская запись.
Пусть в нём есть следующие команды:

`push ЧИСЛО` - кладёт число на вершину стека
`pop` - удаляет вершину стека
`add` - снимает два верхних числа со стека, складывает их и кладёт результат на стек
`mul` - снимает два верхних числа со стека, перемножает их и кладёт результат на стек
`print` - печатает верхушку стека на стандартный вывод

Например, так выглядит программа для подсчёта и вывода значения выражения `(2 + 3) * (4 + 5)`:

```
push 2
push 3
add
push 4
push 5
add
mul
print
```



1) Поместите ваш код со стеком в два файла: stack.h и stack.c.

В файле stack.h будут храниться интерфейсы вашего стека: определение структуры Stack и объявление методов stack_construct и других (без реализации).

В файле stack.c будет храниться реализация вашего стека, будет подключен файл stack.h.

В качестве шаблона я советую взять файлы из этого репозитория.



2) Добавьте файлы cpu.h и cpu.c. В файле cpu.h будет определена структура, моделирующая стековую машину. В простейшем варианте она внутри себя хранит только стек, в более сложном - ещё и регистры. Файл cpu.h подключает файл stack.h.

Также в файле cpu.h объявлены операции для работы с CPU. Во-первых, это будут функции выполнениях всех операций над стековой машиной. Например:
```
CPU_push(cpu, value);
CPU_mul(cpu);
CPU_print(cpu);
```

По сути, пока что почти все эти команды просто вызывают соответствующие команды для стека, который в стековой машине хранится.

Во-вторых, стоит добавить функцию `CPU_run(file)`, которая принимает имя файла и выполняет набор команд, записанный в нём. Функция `CPU_run()` считывает из файла команды и для каждой команды вызывает свою функцию `CPU_*()`.

Работа с файлами осуществляется командами fopen и fclose, строка из файла считывается командой getline, кусочки строки - через fscanf. Сравнение строк производится через strcmp. Ещё бывает функция atoi, например.

*Внимательно читайте пример к функции getline. В нём всё важно. Даже странная строчка `#define _GNU_SOURCE`.*




3) Напишите две программы: ассемблер и интерпретатор. Ассемблер принимает файл с кодом программы на языке стековой машины и преобразует все строчки в числа по какому-нибудь правилу. Например, `push == 1`, `add == 2`, `mul == 3`, `print == 4`.

Программа, приведённая выше, превратится в 
```
1 2
1 3
2
1 4
1 5
2
3
4
```

Напишите также интерпретатор, который будет принимать первым параметром имя файла с ассемблированной программой и выполнять его.

Советую реализовать третью часть, добавив в модуль `cpu` функции `CPU_run_assembled(file)`, `assemble(source_file, asm_file)`.

Подумайте, почему в эти функции лучше передавать файл типа `FILE *`, а не имя файла типа `const char *`.
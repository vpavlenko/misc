Задача 4. Стековая машина
=========================

Рассмотрим язык, расширяющий язык из задачи "Обратная польская запись".
Пусть в нём есть следующие команды:

- `push ЧИСЛО` - кладёт число на вершину стека
- `pop` - удаляет вершину стека
- `add` - снимает два верхних числа со стека, складывает их и кладёт результат на стек
- `mul` - снимает два верхних числа со стека, перемножает их и кладёт результат на стек
- `out` - печатает верхушку стека на стандартный вывод

Например, так выглядит программа для подсчёта и вывода значения выражения `(2 + 3) * (4 + 5)`:

```asm
push 2
push 3
add
push 4
push 5
add
mul
out
```


1. Раскладка файлов
-------------------

Поместите ваш код со стеком в два файла: stack.h и stack.c.

В файле stack.h будут храниться интерфейсы вашего стека: определение структуры Stack и объявление методов stack_construct и других (без реализации).

В файле stack.c будет храниться реализация вашего стека, будет подключен файл stack.h.

Положите основную программу для вычисления выражения в обратной польской записи в файл main.c

Смысл этой раскладки в следующем:

1. По файлу stack.c можно собрать статическую или динамическую библиотеку для работы со стеками, которая не зависит от конкретной задачи вычисления выражения.

2. Эту библиотеку можно использовать при написании и компиляции кода, имея лишь объявления стека и функций для работы с ним, т. е. файл stack.h.

3. Программа собирается в два этапа: компиляция всех файлов кода в объектные файлы и сборка (линковка) всех объектных файлов в один исполняемый.



2. Операции над стековой машиной
--------------------------------

Добавьте файлы cpu.h и cpu.c. В файле cpu.h будет определена структура, моделирующая стековую машину. В простейшем варианте она внутри себя хранит только стек, в более сложном - ещё и регистры. Файл cpu.h подключает файл stack.h.

Также в файле cpu.h объявлены операции для работы с CPU. Во-первых, это будут функции выполнениях всех операций над стековой машиной. Например:
```c
CPU_push(cpu, value);
CPU_mul(cpu);
```

По сути, пока что почти все эти команды просто вызывают соответствующие команды для стека, который в стековой машине хранится.

Во-вторых, стоит добавить функцию `CPU_run(file)`, которая принимает имя файла и выполняет набор команд, записанный в нём. Функция `CPU_run()` считывает из файла команды и для каждой команды вызывает свою функцию `CPU_*()`.

Работа с файлами осуществляется командами fopen и fclose. Для считывания строк можно пробовать использовать функции fscanf, fgets и getline. Сравнение строк производится через strcmp. Ещё бывает функция atoi, например.

В файле main.c реализуйте получение от пользователя имени файлы для интерпретирования. Его надо получать из параметров запуска программы (argc/argv).



3. Время работы
---------------

Замерьте, насколько производителен ваш интерпретатор.

Для начала породите большую программу. Генерацию большого текста можно сделать, размножив маленький текст программы, приведённый, выше с помощью bash-скрипта. Гуглить конкретику можно так: "bash for range cycle", "bash append to file".

Впрочем, большой текст можно породить и программой на Си, и методом Ctrl+C/Ctrl+V.

Если у вас есть Линукс, то замер времени работы можно осуществить утилитой `time`.

Можно также сделать замер времени в самой программе с использованием модуля `time.h`.

Подберите размер файла для интерпретирования так, чтобы ваш интерпретатор работал несколько секунд. В этом случае можно будет сравнивать производительность исходной версии с попытками ускорить программу.



4. Ассемблер и интерпретатор
----------------------------

Примем в качестве гипотезы, что основное время работы программы тратится на работу со строками исходного файла и распознавание команд через сравнение строк. Попробуем изменить этот процесс и перейдём от работы со строками к работе с файлами.

Напишите две программы: интерпретатор числового набора команд и ассемблер. 
Перейдём от строковых команд к числовым. Например, по такому правилу: `push -> 1`, `add -> 2`, `mul -> 3`, `out -> 4`.

Программа, приведённая выше, превратится в 
```python
1 2
1 3
2
1 4
1 5
2
3
4
```

Ваш интерпретатор числовых команд будет принимать первым параметром имя файла с программой и выполнять его.

Ассемблер будет принимать файл с кодом программы на языке строковых команд (мнемоник) и преобразует все строчки в числа по выбранному правилу.

Советую реализовать третью часть, добавив в модуль `cpu` функции `CPU_run_assembled(cpu, file)`, `assemble(source_file, asm_file)`.

Что лучше передавать в эти функции: файл типа `FILE *` или имя файла типа `const char *`?

Ассемблируйте большую программу, которую вы сделали в пункте 3 для проведения тестов на производительность. Выполните её интерпретатором числовых команд. Замерьте время работы. Удалось ли выиграть по времени за счёт перехода от строковых команд к числовым?



5. Дизассемблер
---------------

Напишите дизассемблер, который переводит программу из числовых кодов в программу из мнемоник.



План разговора на 1 ноября
--------------------------

1. Различия функций `fgets`, `fscanf`, `getline`. Как считать содержимое файла целиком, почему `getc()` возвращает `int`, а не `char`. 

2. Флаги "-v", "-E". Файлы .c/.h/.o/.so/.a. Порядок сборки приложений. One definition rule, include guard.

3. Стандарт POSIX: что такое `#define _GNU_SOURCE` в `man getline`?
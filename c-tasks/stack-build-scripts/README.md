Задача 4. Стековая машина
=========================

Рассмотрим язык, расширяющий язык из задачи обратная польская запись.
Пусть в нём есть следующие команды:

- `push ЧИСЛО` - кладёт число на вершину стека
- `pop` - удаляет вершину стека
- `add` - снимает два верхних числа со стека, складывает их и кладёт результат на стек
- `mul` - снимает два верхних числа со стека, перемножает их и кладёт результат на стек
- `print` - печатает верхушку стека на стандартный вывод

Например, так выглядит программа для подсчёта и вывода значения выражения `(2 + 3) * (4 + 5)`:

```
push 2
push 3
add
push 4
push 5
add
mul
print
```


1) Раскладка файлов
-------------------

Поместите ваш код со стеком в два файла: stack.h и stack.c.

В файле stack.h будут храниться интерфейсы вашего стека: определение структуры Stack и объявление методов stack_construct и других (без реализации).

В файле stack.c будет храниться реализация вашего стека, будет подключен файл stack.h.

В качестве шаблона я советую взять файлы из этого репозитория.



2) Операции над стековой машиной
--------------------------------

Добавьте файлы cpu.h и cpu.c. В файле cpu.h будет определена структура, моделирующая стековую машину. В простейшем варианте она внутри себя хранит только стек, в более сложном - ещё и регистры. Файл cpu.h подключает файл stack.h.

Также в файле cpu.h объявлены операции для работы с CPU. Во-первых, это будут функции выполнениях всех операций над стековой машиной. Например:
```
CPU_push(cpu, value);
CPU_mul(cpu);
CPU_print(cpu);
```

По сути, пока что почти все эти команды просто вызывают соответствующие команды для стека, который в стековой машине хранится.

Во-вторых, стоит добавить функцию `CPU_run(file)`, которая принимает имя файла и выполняет набор команд, записанный в нём. Функция `CPU_run()` считывает из файла команды и для каждой команды вызывает свою функцию `CPU_*()`.

Работа с файлами осуществляется командами fopen и fclose, строка из файла считывается командой getline, кусочки строки - через fscanf. Сравнение строк производится через strcmp. Ещё бывает функция atoi, например.

*Внимательно читайте пример к функции getline. В нём всё важно. Даже странная строчка `#define _GNU_SOURCE`.*




3) Ассемблер и интерпретатор
----------------------------
Напишите две программы: ассемблер и интерпретатор. Ассемблер принимает файл с кодом программы на языке стековой машины и преобразует все строчки в числа по какому-нибудь правилу. Например, `push == 1`, `add == 2`, `mul == 3`, `print == 4`.

Программа, приведённая выше, превратится в 
```
1 2
1 3
2
1 4
1 5
2
3
4
```

Напишите также интерпретатор, который будет принимать первым параметром имя файла с ассемблированной программой и выполнять его.

Советую реализовать третью часть, добавив в модуль `cpu` функции `CPU_run_assembled(file)`, `assemble(source_file, asm_file)`.

Подумайте, почему в эти функции лучше передавать файл типа `FILE *`, а не имя файла типа `const char *`.



4) Время работы
---------------

Смысл ассемблирования в том, что файл с кодами-числами быстрее выполняется, поскольку сравнение строк может производиться дольше. Хотя, на самом деле, лучше честно замерить время на каком-нибудь большом тесте стандартной командой `time`.

Напишите скриптик `time.sh`, который осуществляет генерацию большого исходного текста, вызов ассемблера и замер времени работы интерпретатора двумя способами: из исходного текст и из ассемблера.

Генерацию большого текста можно сделать, размножим маленький текст из файлика выше с помощью bash-скрипта. Гуглить так:
"bash for range cycle", "bash append to file".
